/**
 * Copyright (C) 2012-2013 Versile AS
 *
 * This file is part of Versile Java.
 *
 * Versile Java is free software: you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/>.
 */

package org.versile.crypto.x509;

import java.security.interfaces.RSAPublicKey;
import java.util.LinkedList;

import org.versile.common.asn1.VASN1Boolean;
import org.versile.common.asn1.VASN1Exception;
import org.versile.common.asn1.VASN1ObjectIdentifier;
import org.versile.common.asn1.VASN1OctetString;
import org.versile.common.asn1.VASN1Sequence;
import org.versile.common.util.VObjectIdentifier;
import org.versile.crypto.VCryptoException;
import org.versile.crypto.asn1.cert.Extension;



/**
 * Base X.509 class for certificate extension.
 */
public class VX509CertificateExtension {

	VObjectIdentifier oid;
	boolean critical;
	byte[] der = null;

	/**
	 * Set up extension.
	 *
	 * <p>In order to complete object setup, a derived class must also call {@link #setValue}.</p>
	 *
	 * @param oid extension's identifier
	 * @param isCritical if true extension should be registered as 'critical' on a certificate
	 */
	public VX509CertificateExtension(VObjectIdentifier oid, boolean isCritical) {
		this.oid = oid;
		this.critical = isCritical;
	}

	/**
	 * Register the extension's associated value.
	 *
	 * <p>Must be called by a derived class during construction to set extension value.</p>
	 *
	 * @param value extension DER-encoded value
	 */
	protected void setValue(byte[] value) {
		this.der = value;
	}

	/**
	 * Generate an ASN.1 X.509 Extension representation of the extension.
	 *
	 * @return ASN.1 representaiton
	 */
	public VASN1Sequence encodeASN1() {
		VASN1Sequence result = new Extension().create();
		try {
			result.append(new VASN1ObjectIdentifier(oid), "extnID");
			result.append(new VASN1Boolean(critical), "critical", !critical);
			result.append(new VASN1OctetString(der), "extnValue");
		} catch (VASN1Exception e) {
			// Should never happen
			throw new RuntimeException(e);
		}
		return result;
	}

	/**
	 * Generate an DER X.509 Extension representation of the extension.
	 *
	 * @return ASN.1 representaiton
	 */
	public byte[] encodeDer() {
		try {
			return this.encodeASN1().encodeDER();
		} catch (VASN1Exception e) {
			// Should never happen
			throw new RuntimeException(e);
		}
	}

	/**
	 * Create an extension object from parsed ASN.1 extension data.
	 *
	 * <p>'data' must be an ASN.1 object which was generated by performing
	 * a parse operation on a {@link org.versile.crypto.asn1.cert.Extension}.</p>
	 *
	 * @param asn1 extension ASN.1 representation
	 * @return parsed extension
	 * @throws VCryptoException unable to resolve extension data
	 */
	public static VX509CertificateExtension parse(VASN1Sequence asn1)
			throws VCryptoException {
		VObjectIdentifier oid = ((VASN1ObjectIdentifier)asn1.get("extnID")).getValue();
		boolean critical = ((VASN1Boolean)asn1.get("critical")).getValue();
		byte[] der = ((VASN1OctetString)asn1.get("extnValue")).getValue();
		return VX509CertificateExtension.parse(oid, critical, der);
	}

	/**
	 * Create extension by parsing extension's DER value.
	 *
	 * @param oid extension identifier
	 * @param isCritical true if extension is critical
	 * @param der DER representation of extension value
	 * @return parsed certificate
	 * @throws VCryptoException unable to create extension
	 */
	public static VX509CertificateExtension parse(VObjectIdentifier oid, boolean isCritical, byte[] der)
			throws VCryptoException {
		if (oid.equals(VX509BasicConstraint.IDENTIFIER))
			return VX509BasicConstraint.parse(isCritical, der);
		else if (oid.equals(VX509SubjectKeyIdentifier.IDENTIFIER))
			return VX509SubjectKeyIdentifier.parse(isCritical, der);
		else if (oid.equals(VX509KeyUsage.IDENTIFIER))
			return VX509KeyUsage.parse(isCritical, der);
		else if (oid.equals(VX509AuthorityKeyIdentifier.IDENTIFIER))
			return VX509AuthorityKeyIdentifier.parse(isCritical, der);
		else {
			VX509CertificateExtension result = new VX509CertificateExtension(oid, isCritical);
			result.setValue(der);
			return result;
		}
	}

	/**
	 * Generates certificate extensions for a Certificate Authority.
	 *
	 * <p>Usage bits is a bitwise OR of {@link VX509KeyUsage} key usage flags.</p>
	 *
	 * @param caPubKey CA's public key
	 * @param pathLength maximum path length constraint (none if negative)
	 * @param usageBits CA certificate key usage bits (default if negative)
	 * @return appropriate certificate extensions
	 */
	public static VX509CertificateExtension[] createCAExtensions(RSAPublicKey caPubKey, int pathLength, int usageBits) {
		LinkedList<VX509CertificateExtension> certs = new LinkedList<VX509CertificateExtension>();

		certs.addLast(new VX509BasicConstraint(true, true, pathLength));

		byte[] _ski = VX509SubjectKeyIdentifier.generateKeyIdentifier(caPubKey);
		certs.addLast(new VX509SubjectKeyIdentifier(_ski));

		if (usageBits < 0)
			usageBits = VX509KeyUsage.KEY_CERT_SIGN | VX509KeyUsage.CRL_SIGN;
		certs.addLast(new VX509KeyUsage(usageBits));

		return certs.toArray(new VX509CertificateExtension[0]);
	}

	/**
	 * Get associated extension identifier.
	 *
	 * @return extension identifier
	 */
	public VObjectIdentifier getOid() {
		return oid;
	}

	/**
	 * Check if extension is critical.
	 *
	 * @return true if critical
	 */
	public boolean isCritical() {
		return critical;
	}

	/**
	 * Get 'value' of extension's ASN.1 Extension encoding.
	 *
	 * @return value of ASN.1 encoding
	 */
	public byte[] getDer() {
		return der;
	}
}
