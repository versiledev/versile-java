/**
 * Copyright (C) 2012-2013 Versile AS
 *
 * This file is part of Versile Java.
 *
 * Versile Java is free software: you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/>.
 */

package org.versile.orb.url;

import java.lang.reflect.Method;
import java.util.LinkedList;
import java.util.Map;

import org.versile.common.call.VCall;
import org.versile.common.call.VCallCancelled;
import org.versile.common.call.VCallException;
import org.versile.common.call.VCallExceptionHandler;
import org.versile.common.call.VCallHaveResult;
import org.versile.common.call.VCallResultHandler;
import org.versile.orb.entity.VEntity;
import org.versile.orb.entity.VObject;
import org.versile.orb.entity.VProxy;
import org.versile.orb.entity.VString;
import org.versile.orb.entity.VTuple;
import org.versile.orb.link.VLink;


/**
 * Resolves a resource referenced by a Versile Resource Identifier (VRI).
 *
 * <p>A resolver is not instanted directly, but is generated by methods initiating
 * link connection such as {@link VUrlBase#connect()}.</p>
 */
public class VUrlResolver {

	VLink link;
	VUrlData urldata;
	boolean resolve_called = false;

	VUrlResolver(VLink link, VUrlData urldata) {
		this.link = link;
		this.urldata = urldata;
	}

	/**
	 * Resolve VRI as blocking operation.
	 *
	 * @return VRI resolution result
	 * @throws VUrlException error resolving VRI
	 */
	public Object resolve()
		throws VUrlException {

		// Resolve by waiting on non-blocking resolve method
		VCall<Object> call = this.nowaitResolve();
		VUrlException _exc;
		try {
			return call.getResult();
		} catch (VCallCancelled e) {
			// Should never happen
			_exc = new VUrlException(e);
		} catch (VCallException e) {
			Exception e2 = e.getException();
			if (e2 instanceof VUrlException)
				_exc = (VUrlException)e2;
			else
				_exc = new VUrlException(e2);
		}
		throw _exc;
	}

	/**
	 * Resolve VRI as blocking operation.
	 *
	 * @return VRI resolution result
	 * @throws VUrlException error resolving VRI
	 */
	public ResolveResult resolveWithLink()
		throws VUrlException {

		// Resolve by waiting on non-blocking resolve method
		VCall<ResolveResult> call = this.nowaitResolveWithLink();
		VUrlException _exc;
		try {
			return call.getResult();
		} catch (VCallCancelled e) {
			// Should never happen
			_exc = new VUrlException(e);
		} catch (VCallException e) {
			Exception e2 = e.getException();
			if (e2 instanceof VUrlException)
				_exc = (VUrlException)e2;
			else
				_exc = new VUrlException(e2);
		}
		throw _exc;
	}

	/**
	 * Resolve VRI as non-blocking operation.
	 *
	 * @return reference to VRI resolution result
	 */
	public VCall<Object> nowaitResolve() {
		VCall<ResolveResult> call = this.nowaitResolveWithLink();
		class Result extends VCall<Object> {
			VCall<ResolveResult> call;
			public Result(VCall<ResolveResult> call) {
				this.call = call;
			}
			@Override
			public synchronized void pushException(Exception e)
					throws VCallHaveResult, VCallCancelled {
				call.cancel();
				super.pushException(e);
			}
			@Override
			protected void _cancel() {
				call.cancel();
			}
		}
		class ResHandler implements VCallResultHandler<ResolveResult> {
			VCall<Object> _res;
			public ResHandler(VCall<Object> result) {
				_res = result;
			}
			@Override
			public void callback(ResolveResult result) {
				_res.silentPushResult(result.getResource());
			}
		}
		VCall<Object> result = new Result(call);
		call.addHandlerPair(new ResHandler(result), result.pushExceptionHandler());
		return result;
	}

	/**
	 * Resolve VRI as non-blocking operation.
	 *
	 * @return reference to VRI resolution result
	 */
	public VCall<ResolveResult> nowaitResolveWithLink() {
		VCall<ResolveResult> result = new AsyncResolveResult(link);
		try {
			synchronized(this) {
				if (resolve_called)
					throw new VUrlException("Resolve operation already performed");
				resolve_called = true;
			}
			class GatewayHandler implements VCallResultHandler<VProxy> {
				VCall<ResolveResult> result;
				VUrlData urldata;
				public GatewayHandler(VCall<ResolveResult> result, VUrlData urldata) {
					this.result = result;
					this.urldata = urldata;
				}
				@Override
				public void callback(VProxy gw) {
					VCall<Object> call = VUrlResolver.internalNowaitResolve(gw, urldata);
					class ResHandler implements VCallResultHandler<Object> {
						VCall<ResolveResult> _res;
						public ResHandler(VCall<ResolveResult> result) {
							_res = result;
						}
						@Override
						public void callback(Object result) {
							_res.silentPushResult(new ResolveResult(result, link));
						}
					}
					call.addHandlerPair(new ResHandler(result), result.pushExceptionHandler());
				}
			}
			VCall<VProxy> gw_call = link.nowaitPeerGateway();
			gw_call.addHandlerPair(new GatewayHandler(result, urldata),
								   result.pushExceptionHandler(new VUrlException("Resolution error")));
		} catch (VUrlException e) {
			result.silentPushException(e);
		}
		return result;
	}

	/**
	 * Resolve a partial VRI string as blocking operation.
	 *
	 * @param gateway referenced object to resolve partial VRI relative to
	 * @param relativeUrl partial VRI string
	 * @return resolution result
	 * @throws VUrlException error resolving VRI
	 */
	public static Object relative(VProxy gateway, String relativeUrl)
		throws VUrlException {
		if (relativeUrl == null)
			throw new VUrlException("Relative URL cannot be null");
		if (!relativeUrl.startsWith("/"))
			throw new VUrlException("Relative URL must begin with '/'");
		String vri = "vop://dummy" + relativeUrl;
		VUrlData urldata = new VUrlData(vri);
		return VUrlResolver.internalResolve(gateway, urldata);
	}

	/**
	 * Resolve a partial VRI string as a non-blocking operation.
	 *
	 * @param gateway referenced object to resolve partial VRI relative to
	 * @param relativeUrl partial VRI string
	 * @return reference to resolution result
	 */
	public static VCall<Object> nowaitRelative(VProxy gateway, String relativeUrl) {
		try {
			if (relativeUrl == null)
				throw new VUrlException("Relative URL cannot be null");
			else if (!relativeUrl.startsWith("/"))
				throw new VUrlException("Relative URL must begin with '/'");

			String vri = "vop://dummy" + relativeUrl;
			VUrlData urldata = new VUrlData(vri);
			return VUrlResolver.internalNowaitResolve(gateway, urldata);
		} catch (VUrlException e) {
			VCall<Object> result = new VCall<Object>();
			result.silentPushException(e);
			return result;
		}
	}

	static Object internalResolve(VProxy top, VUrlData urldata)
			throws VUrlException {
		// Traverse path
		Object resource = top;
		String[] path = urldata.getPath();
		if (path.length > 0) {
			LinkedList<VEntity> e_list = new LinkedList<VEntity>();
			for (String s: path)
				e_list.addLast(new VString(s));
			Object obj = null;
			try {
				obj = top.call("urlget", new VTuple(e_list));
			} catch (Exception e) {
				throw new VUrlException("Could not traverse URL path");
			}
			// Ensure VReference is represented as a VProxy
			if (obj instanceof VObject)
				resource = new VProxy((VObject)obj);
			else
				resource = obj;
		}

		// Execute query
		String query_name = urldata.getQueryName();
		if (query_name == null)
			return resource;
		Object[] query_args = urldata.getQueryArgs();
		if (query_args == null)
			query_args = new Object[0];
		Map<String, Object> query_kargs = urldata.getQueryNamedArgs();
		Object[] args = null;
		if (query_kargs == null || query_kargs.isEmpty())
			args = new Object[query_args.length];
		else {
			// Append keyword argument map as an extra argument
			args = new Object[query_args.length+1];
			args[args.length-1] = query_kargs;
		}
		for (int i = 0; i < query_args.length; i++)
			args[i] = query_args[i];

		Method remote_call = null;
		if (!(resource instanceof VProxy)) {
			throw new VUrlException("Attempted executing query on " + resource.getClass());
		}
		try {
			Class<?> arg_cls = (new Object[0]).getClass();
			remote_call = ((VProxy)resource).getClass().getMethod("call", String.class, arg_cls);
		} catch (Exception e) {
			throw new RuntimeException("Internal VUrlResolver error");
		}
		try {
			return remote_call.invoke(resource, query_name, args);
		} catch (Exception e) {
			throw new VUrlException("Error performing query", e);
		}
	}

	static VCall<Object> internalNowaitResolve(VProxy top, VUrlData urldata) {
		// If needed traverse path
		VCall<Object> resource = new VCall<Object>();
		String[] path = urldata.getPath();
		if (path.length > 0) {
			class ResultHandler implements VCallResultHandler<Object> {
				VCall<Object> result;
				public ResultHandler(VCall<Object> result) {
					this.result = result;
				}
				@Override
				public void callback(Object obj) {
					Object resource = null;
					if (obj instanceof VObject)
						resource = new VProxy((VObject)obj);
					else
						resource = obj;
					result.silentPushResult(resource);
				}
			}
			LinkedList<VEntity> e_list = new LinkedList<VEntity>();
			for (String s: path)
				e_list.addLast(new VString(s));
			VCall<Object> call = top.nowait("urlget", new VTuple(e_list));
			class UrlgetExcHandler implements VCallExceptionHandler {
				VCall<Object> _resource;
				public UrlgetExcHandler(VCall<Object> resource) {
					this._resource = resource;
				}
				@Override
				public void callback(Exception e) {
					Exception _exc = new VUrlException("URL path did not resolve", e);
					_resource.silentPushException(_exc);
				}
			}
			call.addHandlerPair(new ResultHandler(resource), new UrlgetExcHandler(resource));
		}
		else {
			resource.silentPushResult(top);
		}

		// If no query return resolved path resource
		String query_name = urldata.getQueryName();
		if (query_name == null)
			return resource;

		// Execute query
		VCall<Object> result = new VCall<Object>();
		class ResourceHandler implements VCallResultHandler<Object> {
			VUrlData urldata;
			VCall<Object> result;
			public ResourceHandler(VUrlData urldata, VCall<Object> result) {
				this.urldata = urldata;
				this.result = result;
			}
			@SuppressWarnings("unchecked")
			@Override
			public void callback(Object resource) {
				String query_name = urldata.getQueryName();
				Object[] query_args = urldata.getQueryArgs();
				Map<String, Object> query_kargs = urldata.getQueryNamedArgs();
				Object[] args = null;
				if (query_kargs.isEmpty())
					args = new Object[query_args.length];
				else {
					// Append keyword argument map as an extra argument
					args = new Object[query_args.length+1];
					args[args.length-1] = query_kargs;
				}
				for (int i = 0; i < query_args.length; i++)
					args[i] = query_args[i];

				Method remote_call = null;
				if (!(resource instanceof VProxy)) {
					result.silentPushException(new VUrlException("Attempted executing query on " + resource.getClass()));
					return;
				}
				try {
					Class<?> arg_cls = (new Object[0]).getClass();
					remote_call = resource.getClass().getMethod("nowait", String.class, arg_cls);
				} catch (Exception e) {
					throw new RuntimeException("Internal VUrlResolver error");
				}
				VCall<Object> call = null;
				try {
					call = (VCall<Object>)(remote_call.invoke(resource, query_name, args));
				} catch (Exception e) {
					result.silentPushException(new VUrlException("Error performing query"));
					return;
				}
				call.addHandlerPair(result.pushResultHandler(), result.pushExceptionHandler());
			}
		}
		resource.addHandlerPair(new ResourceHandler(urldata, result), result.pushExceptionHandler());
		return result;
	}

	/**
	 * Resolve result which includes both a resource and link.
	 */
	public static class ResolveResult {
		Object resource;
		VLink link;
		public ResolveResult (Object resource, VLink link) {
			this.resource = resource;
			this.link = link;
		}
		/**
		 * Get resolved resource.
		 *
		 * @return resolved resource
		 */
		public Object getResource() {
			return resource;
		}
		/**
		 * Get resolved link.
		 *
		 * @return link
		 */
		public VLink getLink() {
			return link;
		}
	}

	static class AsyncResolveResult extends VCall<ResolveResult> {
		VLink link;
		public AsyncResolveResult(VLink link) {
			this.link = link;
		}

		@Override
		public synchronized void pushException(Exception e)
				throws VCallHaveResult, VCallCancelled {
			// If an exception is raised during resolve the associated link should be terminated
			VLink _link = link;
			link = null;
			if (_link != null) {
				_link.shutdown(true);
				link = null;
			}
			super.pushException(e);
		}
		@Override
		protected void _cancel() {
			VLink _link = link;
			link = null;
			if (_link != null) {
				_link.shutdown(true);
			}
		}
	}
}
